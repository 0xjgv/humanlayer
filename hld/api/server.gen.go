// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	strictgin "github.com/oapi-codegen/runtime/strictmiddleware/gin"
)

// Defines values for ApprovalStatus.
const (
	ApprovalStatusApproved ApprovalStatus = "approved"
	ApprovalStatusDenied   ApprovalStatus = "denied"
	ApprovalStatusPending  ApprovalStatus = "pending"
)

// Defines values for ConversationEventApprovalStatus.
const (
	ConversationEventApprovalStatusApproved ConversationEventApprovalStatus = "approved"
	ConversationEventApprovalStatusDenied   ConversationEventApprovalStatus = "denied"
	ConversationEventApprovalStatusPending  ConversationEventApprovalStatus = "pending"
	ConversationEventApprovalStatusResolved ConversationEventApprovalStatus = "resolved"
)

// Defines values for ConversationEventEventType.
const (
	ConversationEventEventTypeMessage    ConversationEventEventType = "message"
	ConversationEventEventTypeSystem     ConversationEventEventType = "system"
	ConversationEventEventTypeThinking   ConversationEventEventType = "thinking"
	ConversationEventEventTypeToolCall   ConversationEventEventType = "tool_call"
	ConversationEventEventTypeToolResult ConversationEventEventType = "tool_result"
)

// Defines values for ConversationEventRole.
const (
	ConversationEventRoleAssistant ConversationEventRole = "assistant"
	ConversationEventRoleSystem    ConversationEventRole = "system"
	ConversationEventRoleUser      ConversationEventRole = "user"
)

// Defines values for CreateSessionRequestModel.
const (
	Opus   CreateSessionRequestModel = "opus"
	Sonnet CreateSessionRequestModel = "sonnet"
)

// Defines values for DecideApprovalRequestDecision.
const (
	Approve DecideApprovalRequestDecision = "approve"
	Deny    DecideApprovalRequestDecision = "deny"
)

// Defines values for EventType.
const (
	ApprovalResolved       EventType = "approval_resolved"
	ConversationUpdated    EventType = "conversation_updated"
	NewApproval            EventType = "new_approval"
	SessionSettingsChanged EventType = "session_settings_changed"
	SessionStatusChanged   EventType = "session_status_changed"
)

// Defines values for HealthResponseStatus.
const (
	Ok HealthResponseStatus = "ok"
)

// Defines values for InterruptSessionResponseDataStatus.
const (
	InterruptSessionResponseDataStatusInterrupting InterruptSessionResponseDataStatus = "interrupting"
)

// Defines values for SessionStatus.
const (
	SessionStatusCompleted    SessionStatus = "completed"
	SessionStatusFailed       SessionStatus = "failed"
	SessionStatusInterrupted  SessionStatus = "interrupted"
	SessionStatusInterrupting SessionStatus = "interrupting"
	SessionStatusRunning      SessionStatus = "running"
	SessionStatusStarting     SessionStatus = "starting"
	SessionStatusWaitingInput SessionStatus = "waiting_input"
)

// Approval defines model for Approval.
type Approval struct {
	// Comment Approver's comment
	Comment *string `json:"comment,omitempty"`

	// CreatedAt Creation timestamp
	CreatedAt time.Time `json:"created_at"`

	// Id Unique approval identifier
	Id string `json:"id"`

	// RespondedAt Response timestamp
	RespondedAt *time.Time `json:"responded_at"`

	// RunId Associated run ID
	RunId string `json:"run_id"`

	// SessionId Associated session ID
	SessionId string `json:"session_id"`

	// Status Current status of the approval
	Status ApprovalStatus `json:"status"`

	// ToolInput Tool input parameters
	ToolInput map[string]interface{} `json:"tool_input"`

	// ToolName Tool requesting approval
	ToolName string `json:"tool_name"`
}

// ApprovalResponse defines model for ApprovalResponse.
type ApprovalResponse struct {
	Data Approval `json:"data"`
}

// ApprovalStatus Current status of the approval
type ApprovalStatus string

// ApprovalsResponse defines model for ApprovalsResponse.
type ApprovalsResponse struct {
	Data []Approval `json:"data"`
}

// BulkArchiveRequest defines model for BulkArchiveRequest.
type BulkArchiveRequest struct {
	// Archived True to archive, false to unarchive
	Archived bool `json:"archived"`

	// SessionIds Sessions to archive/unarchive
	SessionIds []string `json:"session_ids"`
}

// BulkArchiveResponse defines model for BulkArchiveResponse.
type BulkArchiveResponse struct {
	Data struct {
		// FailedSessions Sessions that failed to update
		FailedSessions *[]string `json:"failed_sessions,omitempty"`
		Success        bool      `json:"success"`
	} `json:"data"`
}

// ContinueSessionRequest defines model for ContinueSessionRequest.
type ContinueSessionRequest struct {
	// AllowedTools Allowed tools list
	AllowedTools *[]string `json:"allowed_tools,omitempty"`

	// AppendSystemPrompt Append to system prompt
	AppendSystemPrompt *string `json:"append_system_prompt,omitempty"`

	// CustomInstructions Custom instructions
	CustomInstructions *string `json:"custom_instructions,omitempty"`

	// DisallowedTools Disallowed tools list
	DisallowedTools *[]string `json:"disallowed_tools,omitempty"`

	// MaxTurns Max conversation turns
	MaxTurns  *int       `json:"max_turns,omitempty"`
	McpConfig *MCPConfig `json:"mcp_config,omitempty"`

	// PermissionPromptTool MCP tool for permissions
	PermissionPromptTool *string `json:"permission_prompt_tool,omitempty"`

	// Query New query to continue with
	Query string `json:"query"`

	// SystemPrompt Override system prompt
	SystemPrompt *string `json:"system_prompt,omitempty"`
}

// ContinueSessionResponse defines model for ContinueSessionResponse.
type ContinueSessionResponse struct {
	Data struct {
		ClaudeSessionId string `json:"claude_session_id"`
		ParentSessionId string `json:"parent_session_id"`
		RunId           string `json:"run_id"`
		SessionId       string `json:"session_id"`
	} `json:"data"`
}

// ConversationEvent defines model for ConversationEvent.
type ConversationEvent struct {
	// ApprovalId Associated approval ID
	ApprovalId *string `json:"approval_id"`

	// ApprovalStatus Approval status for tool calls
	ApprovalStatus  *ConversationEventApprovalStatus `json:"approval_status"`
	ClaudeSessionId *string                          `json:"claude_session_id,omitempty"`

	// Content Message content
	Content   *string   `json:"content,omitempty"`
	CreatedAt time.Time `json:"created_at"`

	// EventType Type of conversation event
	EventType ConversationEventEventType `json:"event_type"`
	Id        int64                      `json:"id"`

	// IsCompleted Whether tool call has received result
	IsCompleted *bool `json:"is_completed,omitempty"`

	// ParentToolUseId Parent tool use ID for nested calls
	ParentToolUseId *string `json:"parent_tool_use_id,omitempty"`

	// Role Message role (for message events)
	Role *ConversationEventRole `json:"role,omitempty"`

	// Sequence Sequence number in conversation
	Sequence  int    `json:"sequence"`
	SessionId string `json:"session_id"`

	// ToolId Tool invocation ID (for tool events)
	ToolId *string `json:"tool_id,omitempty"`

	// ToolInputJson JSON string of tool input (for tool_call events)
	ToolInputJson *string `json:"tool_input_json,omitempty"`

	// ToolName Tool name (for tool_call events)
	ToolName *string `json:"tool_name,omitempty"`

	// ToolResultContent Tool result content
	ToolResultContent *string `json:"tool_result_content,omitempty"`

	// ToolResultForId Tool call ID this result is for
	ToolResultForId *string `json:"tool_result_for_id,omitempty"`
}

// ConversationEventApprovalStatus Approval status for tool calls
type ConversationEventApprovalStatus string

// ConversationEventEventType Type of conversation event
type ConversationEventEventType string

// ConversationEventRole Message role (for message events)
type ConversationEventRole string

// ConversationResponse defines model for ConversationResponse.
type ConversationResponse struct {
	Data []ConversationEvent `json:"data"`
}

// CreateApprovalRequest defines model for CreateApprovalRequest.
type CreateApprovalRequest struct {
	// RunId Run ID for the approval
	RunId string `json:"run_id"`

	// ToolInput Tool input parameters
	ToolInput map[string]interface{} `json:"tool_input"`

	// ToolName Name of the tool requesting approval
	ToolName string `json:"tool_name"`
}

// CreateApprovalResponse defines model for CreateApprovalResponse.
type CreateApprovalResponse struct {
	Data struct {
		// ApprovalId Created approval ID
		ApprovalId string `json:"approval_id"`
	} `json:"data"`
}

// CreateSessionRequest defines model for CreateSessionRequest.
type CreateSessionRequest struct {
	// AllowedTools Whitelist of allowed tools
	AllowedTools *[]string `json:"allowed_tools,omitempty"`

	// AppendSystemPrompt Text to append to system prompt
	AppendSystemPrompt *string `json:"append_system_prompt,omitempty"`

	// CustomInstructions Custom instructions for Claude
	CustomInstructions *string `json:"custom_instructions,omitempty"`

	// DangerouslySkipPermissions Launch session with dangerously skip permissions enabled
	DangerouslySkipPermissions *bool `json:"dangerously_skip_permissions,omitempty"`

	// DangerouslySkipPermissionsTimeout Optional default timeout in milliseconds for dangerously skip permissions
	DangerouslySkipPermissionsTimeout *int64 `json:"dangerously_skip_permissions_timeout"`

	// DisallowedTools Blacklist of disallowed tools
	DisallowedTools *[]string `json:"disallowed_tools,omitempty"`

	// MaxTurns Maximum conversation turns
	MaxTurns  *int       `json:"max_turns,omitempty"`
	McpConfig *MCPConfig `json:"mcp_config,omitempty"`

	// Model Model to use for the session
	Model *CreateSessionRequestModel `json:"model,omitempty"`

	// PermissionPromptTool MCP tool for permission prompts
	PermissionPromptTool *string `json:"permission_prompt_tool,omitempty"`

	// Query Initial query for Claude
	Query string `json:"query"`

	// SystemPrompt Override system prompt
	SystemPrompt *string `json:"system_prompt,omitempty"`

	// Title Optional title for the session
	Title *string `json:"title,omitempty"`

	// Verbose Enable verbose output
	Verbose *bool `json:"verbose,omitempty"`

	// WorkingDir Working directory for the session
	WorkingDir *string `json:"working_dir,omitempty"`
}

// CreateSessionRequestModel Model to use for the session
type CreateSessionRequestModel string

// CreateSessionResponse defines model for CreateSessionResponse.
type CreateSessionResponse struct {
	Data struct {
		// RunId Created run ID
		RunId string `json:"run_id"`

		// SessionId Created session ID
		SessionId string `json:"session_id"`
	} `json:"data"`
}

// DatabaseInfoResponse defines model for DatabaseInfoResponse.
type DatabaseInfoResponse struct {
	// LastModified Last modification time of the database file
	LastModified *time.Time `json:"last_modified,omitempty"`

	// Path Path to the SQLite database file
	Path string `json:"path"`

	// Size Size of the database file in bytes
	Size int64 `json:"size"`

	// Stats Database statistics
	Stats map[string]int64 `json:"stats"`

	// TableCount Number of tables in the database
	TableCount int `json:"table_count"`
}

// DecideApprovalRequest defines model for DecideApprovalRequest.
type DecideApprovalRequest struct {
	// Comment Optional comment (required for deny)
	Comment *string `json:"comment,omitempty"`

	// Decision Approval decision
	Decision DecideApprovalRequestDecision `json:"decision"`
}

// DecideApprovalRequestDecision Approval decision
type DecideApprovalRequestDecision string

// DecideApprovalResponse defines model for DecideApprovalResponse.
type DecideApprovalResponse struct {
	Data struct {
		// Error Error message if failed
		Error   *string `json:"error,omitempty"`
		Success bool    `json:"success"`
	} `json:"data"`
}

// ErrorDetail defines model for ErrorDetail.
type ErrorDetail struct {
	// Code Error code (e.g., HLD-101)
	Code string `json:"code"`

	// Details Additional error context
	Details *map[string]interface{} `json:"details,omitempty"`

	// Message Human-readable error message
	Message string `json:"message"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error ErrorDetail `json:"error"`
}

// Event defines model for Event.
type Event struct {
	// Data Event-specific data
	Data map[string]interface{} `json:"data"`

	// Timestamp Event timestamp
	Timestamp time.Time `json:"timestamp"`

	// Type Type of system event
	Type EventType `json:"type"`
}

// EventType Type of system event
type EventType string

// FileSnapshot defines model for FileSnapshot.
type FileSnapshot struct {
	// Content File content at snapshot time
	Content   string    `json:"content"`
	CreatedAt time.Time `json:"created_at"`

	// FilePath Path to the file
	FilePath string `json:"file_path"`

	// ToolId Tool invocation that created snapshot
	ToolId string `json:"tool_id"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	Status  HealthResponseStatus `json:"status"`
	Version string               `json:"version"`
}

// HealthResponseStatus defines model for HealthResponse.Status.
type HealthResponseStatus string

// InterruptSessionResponse defines model for InterruptSessionResponse.
type InterruptSessionResponse struct {
	Data struct {
		SessionId string                             `json:"session_id"`
		Status    InterruptSessionResponseDataStatus `json:"status"`
		Success   bool                               `json:"success"`
	} `json:"data"`
}

// InterruptSessionResponseDataStatus defines model for InterruptSessionResponse.Data.Status.
type InterruptSessionResponseDataStatus string

// MCPConfig defines model for MCPConfig.
type MCPConfig struct {
	// McpServers Map of server name to configuration
	McpServers *map[string]MCPServer `json:"mcpServers,omitempty"`
}

// MCPServer defines model for MCPServer.
type MCPServer struct {
	// Args Command arguments
	Args *[]string `json:"args,omitempty"`

	// Command Command to execute
	Command string `json:"command"`

	// Env Environment variables
	Env *map[string]string `json:"env,omitempty"`
}

// RecentPath defines model for RecentPath.
type RecentPath struct {
	// LastUsed Last time this path was used
	LastUsed time.Time `json:"last_used"`

	// Path Directory path
	Path string `json:"path"`

	// UsageCount Number of times used
	UsageCount int `json:"usage_count"`
}

// RecentPathsResponse defines model for RecentPathsResponse.
type RecentPathsResponse struct {
	Data []RecentPath `json:"data"`
}

// Session defines model for Session.
type Session struct {
	// Archived Whether session is archived
	Archived *bool `json:"archived,omitempty"`

	// AutoAcceptEdits Whether edit tools are auto-accepted
	AutoAcceptEdits *bool `json:"auto_accept_edits,omitempty"`

	// CacheCreationInputTokens Number of cache creation input tokens
	CacheCreationInputTokens *int `json:"cache_creation_input_tokens"`

	// CacheReadInputTokens Number of cache read input tokens
	CacheReadInputTokens *int `json:"cache_read_input_tokens"`

	// ClaudeSessionId Claude's internal session ID
	ClaudeSessionId *string `json:"claude_session_id,omitempty"`

	// CompletedAt Session completion timestamp
	CompletedAt *time.Time `json:"completed_at"`

	// ContextLimit Context window limit for the model
	ContextLimit *int `json:"context_limit"`

	// CostUsd Total cost in USD
	CostUsd *float32 `json:"cost_usd"`

	// CreatedAt Session creation timestamp
	CreatedAt time.Time `json:"created_at"`

	// DangerouslySkipPermissions When true, all tool calls are automatically approved without user consent
	DangerouslySkipPermissions *bool `json:"dangerously_skip_permissions,omitempty"`

	// DangerouslySkipPermissionsExpiresAt ISO timestamp when dangerously skip permissions mode expires (optional)
	DangerouslySkipPermissionsExpiresAt *time.Time `json:"dangerously_skip_permissions_expires_at"`

	// DurationMs Session duration in milliseconds
	DurationMs *int `json:"duration_ms"`

	// EffectiveContextTokens Total tokens counting toward context window limit
	EffectiveContextTokens *int `json:"effective_context_tokens"`

	// ErrorMessage Error message if session failed
	ErrorMessage *string `json:"error_message,omitempty"`

	// Id Unique session identifier
	Id string `json:"id"`

	// InputTokens Number of input tokens
	InputTokens *int `json:"input_tokens"`

	// LastActivityAt Last activity timestamp
	LastActivityAt time.Time `json:"last_activity_at"`

	// Model Model used for this session
	Model *string `json:"model,omitempty"`

	// ModelId Full model identifier
	ModelId *string `json:"model_id,omitempty"`

	// OutputTokens Number of output tokens
	OutputTokens *int `json:"output_tokens"`

	// ParentSessionId Parent session ID if this is a forked session
	ParentSessionId *string `json:"parent_session_id,omitempty"`

	// Query Initial query that started the session
	Query string `json:"query"`

	// RunId Unique run identifier
	RunId string `json:"run_id"`

	// Status Current status of the session
	Status SessionStatus `json:"status"`

	// Summary AI-generated summary of the session
	Summary *string `json:"summary,omitempty"`

	// Title User-editable session title
	Title *string `json:"title,omitempty"`

	// WorkingDir Working directory for the session
	WorkingDir *string `json:"working_dir,omitempty"`
}

// SessionResponse defines model for SessionResponse.
type SessionResponse struct {
	Data Session `json:"data"`
}

// SessionStatus Current status of the session
type SessionStatus string

// SessionsResponse defines model for SessionsResponse.
type SessionsResponse struct {
	Data []Session `json:"data"`
}

// SnapshotsResponse defines model for SnapshotsResponse.
type SnapshotsResponse struct {
	Data []FileSnapshot `json:"data"`
}

// UpdateSessionRequest defines model for UpdateSessionRequest.
type UpdateSessionRequest struct {
	// Archived Archive/unarchive the session
	Archived *bool `json:"archived,omitempty"`

	// AutoAcceptEdits Enable/disable auto-accept for edit tools
	AutoAcceptEdits *bool `json:"auto_accept_edits,omitempty"`

	// DangerouslySkipPermissions Enable or disable dangerously skip permissions mode
	DangerouslySkipPermissions *bool `json:"dangerously_skip_permissions,omitempty"`

	// DangerouslySkipPermissionsTimeoutMs Optional timeout in milliseconds for dangerously skip permissions mode
	DangerouslySkipPermissionsTimeoutMs *int64 `json:"dangerously_skip_permissions_timeout_ms"`

	// Title Update session title
	Title *string `json:"title,omitempty"`
}

// ApprovalId defines model for approvalId.
type ApprovalId = string

// SessionId defines model for sessionId.
type SessionId = string

// BadRequest defines model for BadRequest.
type BadRequest = ErrorResponse

// InternalError defines model for InternalError.
type InternalError = ErrorResponse

// NotFound defines model for NotFound.
type NotFound = ErrorResponse

// ListApprovalsParams defines parameters for ListApprovals.
type ListApprovalsParams struct {
	// SessionId Filter by session ID
	SessionId *string `form:"sessionId,omitempty" json:"sessionId,omitempty"`
}

// GetRecentPathsParams defines parameters for GetRecentPaths.
type GetRecentPathsParams struct {
	// Limit Maximum number of paths to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListSessionsParams defines parameters for ListSessions.
type ListSessionsParams struct {
	// LeafOnly Return only leaf sessions (no children)
	LeafOnly *bool `form:"leafOnly,omitempty" json:"leafOnly,omitempty"`

	// IncludeArchived Include archived sessions in results
	IncludeArchived *bool `form:"includeArchived,omitempty" json:"includeArchived,omitempty"`

	// ArchivedOnly Return only archived sessions
	ArchivedOnly *bool `form:"archivedOnly,omitempty" json:"archivedOnly,omitempty"`
}

// CreateApprovalJSONRequestBody defines body for CreateApproval for application/json ContentType.
type CreateApprovalJSONRequestBody = CreateApprovalRequest

// DecideApprovalJSONRequestBody defines body for DecideApproval for application/json ContentType.
type DecideApprovalJSONRequestBody = DecideApprovalRequest

// CreateSessionJSONRequestBody defines body for CreateSession for application/json ContentType.
type CreateSessionJSONRequestBody = CreateSessionRequest

// BulkArchiveSessionsJSONRequestBody defines body for BulkArchiveSessions for application/json ContentType.
type BulkArchiveSessionsJSONRequestBody = BulkArchiveRequest

// UpdateSessionJSONRequestBody defines body for UpdateSession for application/json ContentType.
type UpdateSessionJSONRequestBody = UpdateSessionRequest

// ContinueSessionJSONRequestBody defines body for ContinueSession for application/json ContentType.
type ContinueSessionJSONRequestBody = ContinueSessionRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List approval requests
	// (GET /approvals)
	ListApprovals(c *gin.Context, params ListApprovalsParams)
	// Create approval request
	// (POST /approvals)
	CreateApproval(c *gin.Context)
	// Get approval details
	// (GET /approvals/{id})
	GetApproval(c *gin.Context, id ApprovalId)
	// Decide on approval request
	// (POST /approvals/{id}/decide)
	DecideApproval(c *gin.Context, id ApprovalId)
	// Get database information
	// (GET /database-info)
	GetDatabaseInfo(c *gin.Context)
	// Health check
	// (GET /health)
	GetHealth(c *gin.Context)
	// Get recent working directories
	// (GET /recent-paths)
	GetRecentPaths(c *gin.Context, params GetRecentPathsParams)
	// List sessions
	// (GET /sessions)
	ListSessions(c *gin.Context, params ListSessionsParams)
	// Launch a new session
	// (POST /sessions)
	CreateSession(c *gin.Context)
	// Bulk archive/unarchive sessions
	// (POST /sessions/archive)
	BulkArchiveSessions(c *gin.Context)
	// Get session details
	// (GET /sessions/{id})
	GetSession(c *gin.Context, id SessionId)
	// Update session settings
	// (PATCH /sessions/{id})
	UpdateSession(c *gin.Context, id SessionId)
	// Continue or fork a session
	// (POST /sessions/{id}/continue)
	ContinueSession(c *gin.Context, id SessionId)
	// Interrupt a running session
	// (POST /sessions/{id}/interrupt)
	InterruptSession(c *gin.Context, id SessionId)
	// Get conversation messages
	// (GET /sessions/{id}/messages)
	GetSessionMessages(c *gin.Context, id SessionId)
	// Get file snapshots
	// (GET /sessions/{id}/snapshots)
	GetSessionSnapshots(c *gin.Context, id SessionId)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// ListApprovals operation middleware
func (siw *ServerInterfaceWrapper) ListApprovals(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListApprovalsParams

	// ------------- Optional query parameter "sessionId" -------------

	err = runtime.BindQueryParameter("form", true, false, "sessionId", c.Request.URL.Query(), &params.SessionId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter sessionId: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListApprovals(c, params)
}

// CreateApproval operation middleware
func (siw *ServerInterfaceWrapper) CreateApproval(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateApproval(c)
}

// GetApproval operation middleware
func (siw *ServerInterfaceWrapper) GetApproval(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id ApprovalId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetApproval(c, id)
}

// DecideApproval operation middleware
func (siw *ServerInterfaceWrapper) DecideApproval(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id ApprovalId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.DecideApproval(c, id)
}

// GetDatabaseInfo operation middleware
func (siw *ServerInterfaceWrapper) GetDatabaseInfo(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetDatabaseInfo(c)
}

// GetHealth operation middleware
func (siw *ServerInterfaceWrapper) GetHealth(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetHealth(c)
}

// GetRecentPaths operation middleware
func (siw *ServerInterfaceWrapper) GetRecentPaths(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecentPathsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", c.Request.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter limit: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetRecentPaths(c, params)
}

// ListSessions operation middleware
func (siw *ServerInterfaceWrapper) ListSessions(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSessionsParams

	// ------------- Optional query parameter "leafOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "leafOnly", c.Request.URL.Query(), &params.LeafOnly)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter leafOnly: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "includeArchived" -------------

	err = runtime.BindQueryParameter("form", true, false, "includeArchived", c.Request.URL.Query(), &params.IncludeArchived)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter includeArchived: %w", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "archivedOnly" -------------

	err = runtime.BindQueryParameter("form", true, false, "archivedOnly", c.Request.URL.Query(), &params.ArchivedOnly)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter archivedOnly: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ListSessions(c, params)
}

// CreateSession operation middleware
func (siw *ServerInterfaceWrapper) CreateSession(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.CreateSession(c)
}

// BulkArchiveSessions operation middleware
func (siw *ServerInterfaceWrapper) BulkArchiveSessions(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.BulkArchiveSessions(c)
}

// GetSession operation middleware
func (siw *ServerInterfaceWrapper) GetSession(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id SessionId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSession(c, id)
}

// UpdateSession operation middleware
func (siw *ServerInterfaceWrapper) UpdateSession(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id SessionId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.UpdateSession(c, id)
}

// ContinueSession operation middleware
func (siw *ServerInterfaceWrapper) ContinueSession(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id SessionId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.ContinueSession(c, id)
}

// InterruptSession operation middleware
func (siw *ServerInterfaceWrapper) InterruptSession(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id SessionId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.InterruptSession(c, id)
}

// GetSessionMessages operation middleware
func (siw *ServerInterfaceWrapper) GetSessionMessages(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id SessionId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSessionMessages(c, id)
}

// GetSessionSnapshots operation middleware
func (siw *ServerInterfaceWrapper) GetSessionSnapshots(c *gin.Context) {

	var err error

	// ------------- Path parameter "id" -------------
	var id SessionId

	err = runtime.BindStyledParameterWithOptions("simple", "id", c.Param("id"), &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter id: %w", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetSessionSnapshots(c, id)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.GET(options.BaseURL+"/approvals", wrapper.ListApprovals)
	router.POST(options.BaseURL+"/approvals", wrapper.CreateApproval)
	router.GET(options.BaseURL+"/approvals/:id", wrapper.GetApproval)
	router.POST(options.BaseURL+"/approvals/:id/decide", wrapper.DecideApproval)
	router.GET(options.BaseURL+"/database-info", wrapper.GetDatabaseInfo)
	router.GET(options.BaseURL+"/health", wrapper.GetHealth)
	router.GET(options.BaseURL+"/recent-paths", wrapper.GetRecentPaths)
	router.GET(options.BaseURL+"/sessions", wrapper.ListSessions)
	router.POST(options.BaseURL+"/sessions", wrapper.CreateSession)
	router.POST(options.BaseURL+"/sessions/archive", wrapper.BulkArchiveSessions)
	router.GET(options.BaseURL+"/sessions/:id", wrapper.GetSession)
	router.PATCH(options.BaseURL+"/sessions/:id", wrapper.UpdateSession)
	router.POST(options.BaseURL+"/sessions/:id/continue", wrapper.ContinueSession)
	router.POST(options.BaseURL+"/sessions/:id/interrupt", wrapper.InterruptSession)
	router.GET(options.BaseURL+"/sessions/:id/messages", wrapper.GetSessionMessages)
	router.GET(options.BaseURL+"/sessions/:id/snapshots", wrapper.GetSessionSnapshots)
}

type BadRequestJSONResponse ErrorResponse

type InternalErrorJSONResponse ErrorResponse

type NotFoundJSONResponse ErrorResponse

type ListApprovalsRequestObject struct {
	Params ListApprovalsParams
}

type ListApprovalsResponseObject interface {
	VisitListApprovalsResponse(w http.ResponseWriter) error
}

type ListApprovals200JSONResponse ApprovalsResponse

func (response ListApprovals200JSONResponse) VisitListApprovalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListApprovals500JSONResponse struct{ InternalErrorJSONResponse }

func (response ListApprovals500JSONResponse) VisitListApprovalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateApprovalRequestObject struct {
	Body *CreateApprovalJSONRequestBody
}

type CreateApprovalResponseObject interface {
	VisitCreateApprovalResponse(w http.ResponseWriter) error
}

type CreateApproval201JSONResponse CreateApprovalResponse

func (response CreateApproval201JSONResponse) VisitCreateApprovalResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateApproval400JSONResponse struct{ BadRequestJSONResponse }

func (response CreateApproval400JSONResponse) VisitCreateApprovalResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateApproval500JSONResponse struct{ InternalErrorJSONResponse }

func (response CreateApproval500JSONResponse) VisitCreateApprovalResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetApprovalRequestObject struct {
	Id ApprovalId `json:"id"`
}

type GetApprovalResponseObject interface {
	VisitGetApprovalResponse(w http.ResponseWriter) error
}

type GetApproval200JSONResponse ApprovalResponse

func (response GetApproval200JSONResponse) VisitGetApprovalResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetApproval404JSONResponse struct{ NotFoundJSONResponse }

func (response GetApproval404JSONResponse) VisitGetApprovalResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetApproval500JSONResponse struct{ InternalErrorJSONResponse }

func (response GetApproval500JSONResponse) VisitGetApprovalResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DecideApprovalRequestObject struct {
	Id   ApprovalId `json:"id"`
	Body *DecideApprovalJSONRequestBody
}

type DecideApprovalResponseObject interface {
	VisitDecideApprovalResponse(w http.ResponseWriter) error
}

type DecideApproval200JSONResponse DecideApprovalResponse

func (response DecideApproval200JSONResponse) VisitDecideApprovalResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DecideApproval400JSONResponse ErrorResponse

func (response DecideApproval400JSONResponse) VisitDecideApprovalResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DecideApproval404JSONResponse struct{ NotFoundJSONResponse }

func (response DecideApproval404JSONResponse) VisitDecideApprovalResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DecideApproval500JSONResponse struct{ InternalErrorJSONResponse }

func (response DecideApproval500JSONResponse) VisitDecideApprovalResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetDatabaseInfoRequestObject struct {
}

type GetDatabaseInfoResponseObject interface {
	VisitGetDatabaseInfoResponse(w http.ResponseWriter) error
}

type GetDatabaseInfo200JSONResponse DatabaseInfoResponse

func (response GetDatabaseInfo200JSONResponse) VisitGetDatabaseInfoResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetHealthRequestObject struct {
}

type GetHealthResponseObject interface {
	VisitGetHealthResponse(w http.ResponseWriter) error
}

type GetHealth200JSONResponse HealthResponse

func (response GetHealth200JSONResponse) VisitGetHealthResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetRecentPathsRequestObject struct {
	Params GetRecentPathsParams
}

type GetRecentPathsResponseObject interface {
	VisitGetRecentPathsResponse(w http.ResponseWriter) error
}

type GetRecentPaths200JSONResponse RecentPathsResponse

func (response GetRecentPaths200JSONResponse) VisitGetRecentPathsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetRecentPaths500JSONResponse struct{ InternalErrorJSONResponse }

func (response GetRecentPaths500JSONResponse) VisitGetRecentPathsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ListSessionsRequestObject struct {
	Params ListSessionsParams
}

type ListSessionsResponseObject interface {
	VisitListSessionsResponse(w http.ResponseWriter) error
}

type ListSessions200JSONResponse SessionsResponse

func (response ListSessions200JSONResponse) VisitListSessionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListSessions500JSONResponse struct{ InternalErrorJSONResponse }

func (response ListSessions500JSONResponse) VisitListSessionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CreateSessionRequestObject struct {
	Body *CreateSessionJSONRequestBody
}

type CreateSessionResponseObject interface {
	VisitCreateSessionResponse(w http.ResponseWriter) error
}

type CreateSession201JSONResponse CreateSessionResponse

func (response CreateSession201JSONResponse) VisitCreateSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type CreateSession400JSONResponse struct{ BadRequestJSONResponse }

func (response CreateSession400JSONResponse) VisitCreateSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CreateSession500JSONResponse struct{ InternalErrorJSONResponse }

func (response CreateSession500JSONResponse) VisitCreateSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type BulkArchiveSessionsRequestObject struct {
	Body *BulkArchiveSessionsJSONRequestBody
}

type BulkArchiveSessionsResponseObject interface {
	VisitBulkArchiveSessionsResponse(w http.ResponseWriter) error
}

type BulkArchiveSessions200JSONResponse BulkArchiveResponse

func (response BulkArchiveSessions200JSONResponse) VisitBulkArchiveSessionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type BulkArchiveSessions207JSONResponse BulkArchiveResponse

func (response BulkArchiveSessions207JSONResponse) VisitBulkArchiveSessionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(207)

	return json.NewEncoder(w).Encode(response)
}

type BulkArchiveSessions400JSONResponse struct{ BadRequestJSONResponse }

func (response BulkArchiveSessions400JSONResponse) VisitBulkArchiveSessionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type BulkArchiveSessions500JSONResponse struct{ InternalErrorJSONResponse }

func (response BulkArchiveSessions500JSONResponse) VisitBulkArchiveSessionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetSessionRequestObject struct {
	Id SessionId `json:"id"`
}

type GetSessionResponseObject interface {
	VisitGetSessionResponse(w http.ResponseWriter) error
}

type GetSession200JSONResponse SessionResponse

func (response GetSession200JSONResponse) VisitGetSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetSession404JSONResponse struct{ NotFoundJSONResponse }

func (response GetSession404JSONResponse) VisitGetSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetSession500JSONResponse struct{ InternalErrorJSONResponse }

func (response GetSession500JSONResponse) VisitGetSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type UpdateSessionRequestObject struct {
	Id   SessionId `json:"id"`
	Body *UpdateSessionJSONRequestBody
}

type UpdateSessionResponseObject interface {
	VisitUpdateSessionResponse(w http.ResponseWriter) error
}

type UpdateSession200JSONResponse SessionResponse

func (response UpdateSession200JSONResponse) VisitUpdateSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type UpdateSession404JSONResponse struct{ NotFoundJSONResponse }

func (response UpdateSession404JSONResponse) VisitUpdateSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdateSession500JSONResponse struct{ InternalErrorJSONResponse }

func (response UpdateSession500JSONResponse) VisitUpdateSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ContinueSessionRequestObject struct {
	Id   SessionId `json:"id"`
	Body *ContinueSessionJSONRequestBody
}

type ContinueSessionResponseObject interface {
	VisitContinueSessionResponse(w http.ResponseWriter) error
}

type ContinueSession201JSONResponse ContinueSessionResponse

func (response ContinueSession201JSONResponse) VisitContinueSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type ContinueSession404JSONResponse struct{ NotFoundJSONResponse }

func (response ContinueSession404JSONResponse) VisitContinueSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ContinueSession500JSONResponse struct{ InternalErrorJSONResponse }

func (response ContinueSession500JSONResponse) VisitContinueSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type InterruptSessionRequestObject struct {
	Id SessionId `json:"id"`
}

type InterruptSessionResponseObject interface {
	VisitInterruptSessionResponse(w http.ResponseWriter) error
}

type InterruptSession200JSONResponse InterruptSessionResponse

func (response InterruptSession200JSONResponse) VisitInterruptSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type InterruptSession400JSONResponse ErrorResponse

func (response InterruptSession400JSONResponse) VisitInterruptSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type InterruptSession404JSONResponse struct{ NotFoundJSONResponse }

func (response InterruptSession404JSONResponse) VisitInterruptSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type InterruptSession500JSONResponse struct{ InternalErrorJSONResponse }

func (response InterruptSession500JSONResponse) VisitInterruptSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetSessionMessagesRequestObject struct {
	Id SessionId `json:"id"`
}

type GetSessionMessagesResponseObject interface {
	VisitGetSessionMessagesResponse(w http.ResponseWriter) error
}

type GetSessionMessages200JSONResponse ConversationResponse

func (response GetSessionMessages200JSONResponse) VisitGetSessionMessagesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetSessionMessages404JSONResponse struct{ NotFoundJSONResponse }

func (response GetSessionMessages404JSONResponse) VisitGetSessionMessagesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetSessionMessages500JSONResponse struct{ InternalErrorJSONResponse }

func (response GetSessionMessages500JSONResponse) VisitGetSessionMessagesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetSessionSnapshotsRequestObject struct {
	Id SessionId `json:"id"`
}

type GetSessionSnapshotsResponseObject interface {
	VisitGetSessionSnapshotsResponse(w http.ResponseWriter) error
}

type GetSessionSnapshots200JSONResponse SnapshotsResponse

func (response GetSessionSnapshots200JSONResponse) VisitGetSessionSnapshotsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetSessionSnapshots404JSONResponse struct{ NotFoundJSONResponse }

func (response GetSessionSnapshots404JSONResponse) VisitGetSessionSnapshotsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetSessionSnapshots500JSONResponse struct{ InternalErrorJSONResponse }

func (response GetSessionSnapshots500JSONResponse) VisitGetSessionSnapshotsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// List approval requests
	// (GET /approvals)
	ListApprovals(ctx context.Context, request ListApprovalsRequestObject) (ListApprovalsResponseObject, error)
	// Create approval request
	// (POST /approvals)
	CreateApproval(ctx context.Context, request CreateApprovalRequestObject) (CreateApprovalResponseObject, error)
	// Get approval details
	// (GET /approvals/{id})
	GetApproval(ctx context.Context, request GetApprovalRequestObject) (GetApprovalResponseObject, error)
	// Decide on approval request
	// (POST /approvals/{id}/decide)
	DecideApproval(ctx context.Context, request DecideApprovalRequestObject) (DecideApprovalResponseObject, error)
	// Get database information
	// (GET /database-info)
	GetDatabaseInfo(ctx context.Context, request GetDatabaseInfoRequestObject) (GetDatabaseInfoResponseObject, error)
	// Health check
	// (GET /health)
	GetHealth(ctx context.Context, request GetHealthRequestObject) (GetHealthResponseObject, error)
	// Get recent working directories
	// (GET /recent-paths)
	GetRecentPaths(ctx context.Context, request GetRecentPathsRequestObject) (GetRecentPathsResponseObject, error)
	// List sessions
	// (GET /sessions)
	ListSessions(ctx context.Context, request ListSessionsRequestObject) (ListSessionsResponseObject, error)
	// Launch a new session
	// (POST /sessions)
	CreateSession(ctx context.Context, request CreateSessionRequestObject) (CreateSessionResponseObject, error)
	// Bulk archive/unarchive sessions
	// (POST /sessions/archive)
	BulkArchiveSessions(ctx context.Context, request BulkArchiveSessionsRequestObject) (BulkArchiveSessionsResponseObject, error)
	// Get session details
	// (GET /sessions/{id})
	GetSession(ctx context.Context, request GetSessionRequestObject) (GetSessionResponseObject, error)
	// Update session settings
	// (PATCH /sessions/{id})
	UpdateSession(ctx context.Context, request UpdateSessionRequestObject) (UpdateSessionResponseObject, error)
	// Continue or fork a session
	// (POST /sessions/{id}/continue)
	ContinueSession(ctx context.Context, request ContinueSessionRequestObject) (ContinueSessionResponseObject, error)
	// Interrupt a running session
	// (POST /sessions/{id}/interrupt)
	InterruptSession(ctx context.Context, request InterruptSessionRequestObject) (InterruptSessionResponseObject, error)
	// Get conversation messages
	// (GET /sessions/{id}/messages)
	GetSessionMessages(ctx context.Context, request GetSessionMessagesRequestObject) (GetSessionMessagesResponseObject, error)
	// Get file snapshots
	// (GET /sessions/{id}/snapshots)
	GetSessionSnapshots(ctx context.Context, request GetSessionSnapshotsRequestObject) (GetSessionSnapshotsResponseObject, error)
}

type StrictHandlerFunc = strictgin.StrictGinHandlerFunc
type StrictMiddlewareFunc = strictgin.StrictGinMiddlewareFunc

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
}

// ListApprovals operation middleware
func (sh *strictHandler) ListApprovals(ctx *gin.Context, params ListApprovalsParams) {
	var request ListApprovalsRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListApprovals(ctx, request.(ListApprovalsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListApprovals")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListApprovalsResponseObject); ok {
		if err := validResponse.VisitListApprovalsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateApproval operation middleware
func (sh *strictHandler) CreateApproval(ctx *gin.Context) {
	var request CreateApprovalRequestObject

	var body CreateApprovalJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateApproval(ctx, request.(CreateApprovalRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateApproval")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(CreateApprovalResponseObject); ok {
		if err := validResponse.VisitCreateApprovalResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetApproval operation middleware
func (sh *strictHandler) GetApproval(ctx *gin.Context, id ApprovalId) {
	var request GetApprovalRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetApproval(ctx, request.(GetApprovalRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetApproval")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetApprovalResponseObject); ok {
		if err := validResponse.VisitGetApprovalResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// DecideApproval operation middleware
func (sh *strictHandler) DecideApproval(ctx *gin.Context, id ApprovalId) {
	var request DecideApprovalRequestObject

	request.Id = id

	var body DecideApprovalJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DecideApproval(ctx, request.(DecideApprovalRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DecideApproval")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(DecideApprovalResponseObject); ok {
		if err := validResponse.VisitDecideApprovalResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetDatabaseInfo operation middleware
func (sh *strictHandler) GetDatabaseInfo(ctx *gin.Context) {
	var request GetDatabaseInfoRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetDatabaseInfo(ctx, request.(GetDatabaseInfoRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetDatabaseInfo")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetDatabaseInfoResponseObject); ok {
		if err := validResponse.VisitGetDatabaseInfoResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetHealth operation middleware
func (sh *strictHandler) GetHealth(ctx *gin.Context) {
	var request GetHealthRequestObject

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetHealth(ctx, request.(GetHealthRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetHealth")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetHealthResponseObject); ok {
		if err := validResponse.VisitGetHealthResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetRecentPaths operation middleware
func (sh *strictHandler) GetRecentPaths(ctx *gin.Context, params GetRecentPathsParams) {
	var request GetRecentPathsRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetRecentPaths(ctx, request.(GetRecentPathsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetRecentPaths")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetRecentPathsResponseObject); ok {
		if err := validResponse.VisitGetRecentPathsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListSessions operation middleware
func (sh *strictHandler) ListSessions(ctx *gin.Context, params ListSessionsParams) {
	var request ListSessionsRequestObject

	request.Params = params

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ListSessions(ctx, request.(ListSessionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListSessions")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ListSessionsResponseObject); ok {
		if err := validResponse.VisitListSessionsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// CreateSession operation middleware
func (sh *strictHandler) CreateSession(ctx *gin.Context) {
	var request CreateSessionRequestObject

	var body CreateSessionJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateSession(ctx, request.(CreateSessionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateSession")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(CreateSessionResponseObject); ok {
		if err := validResponse.VisitCreateSessionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// BulkArchiveSessions operation middleware
func (sh *strictHandler) BulkArchiveSessions(ctx *gin.Context) {
	var request BulkArchiveSessionsRequestObject

	var body BulkArchiveSessionsJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.BulkArchiveSessions(ctx, request.(BulkArchiveSessionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "BulkArchiveSessions")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(BulkArchiveSessionsResponseObject); ok {
		if err := validResponse.VisitBulkArchiveSessionsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSession operation middleware
func (sh *strictHandler) GetSession(ctx *gin.Context, id SessionId) {
	var request GetSessionRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetSession(ctx, request.(GetSessionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSession")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetSessionResponseObject); ok {
		if err := validResponse.VisitGetSessionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdateSession operation middleware
func (sh *strictHandler) UpdateSession(ctx *gin.Context, id SessionId) {
	var request UpdateSessionRequestObject

	request.Id = id

	var body UpdateSessionJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateSession(ctx, request.(UpdateSessionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateSession")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(UpdateSessionResponseObject); ok {
		if err := validResponse.VisitUpdateSessionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// ContinueSession operation middleware
func (sh *strictHandler) ContinueSession(ctx *gin.Context, id SessionId) {
	var request ContinueSessionRequestObject

	request.Id = id

	var body ContinueSessionJSONRequestBody
	if err := ctx.ShouldBindJSON(&body); err != nil {
		ctx.Status(http.StatusBadRequest)
		ctx.Error(err)
		return
	}
	request.Body = &body

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ContinueSession(ctx, request.(ContinueSessionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ContinueSession")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(ContinueSessionResponseObject); ok {
		if err := validResponse.VisitContinueSessionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// InterruptSession operation middleware
func (sh *strictHandler) InterruptSession(ctx *gin.Context, id SessionId) {
	var request InterruptSessionRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.InterruptSession(ctx, request.(InterruptSessionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "InterruptSession")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(InterruptSessionResponseObject); ok {
		if err := validResponse.VisitInterruptSessionResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSessionMessages operation middleware
func (sh *strictHandler) GetSessionMessages(ctx *gin.Context, id SessionId) {
	var request GetSessionMessagesRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetSessionMessages(ctx, request.(GetSessionMessagesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSessionMessages")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetSessionMessagesResponseObject); ok {
		if err := validResponse.VisitGetSessionMessagesResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSessionSnapshots operation middleware
func (sh *strictHandler) GetSessionSnapshots(ctx *gin.Context, id SessionId) {
	var request GetSessionSnapshotsRequestObject

	request.Id = id

	handler := func(ctx *gin.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetSessionSnapshots(ctx, request.(GetSessionSnapshotsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSessionSnapshots")
	}

	response, err := handler(ctx, request)

	if err != nil {
		ctx.Error(err)
		ctx.Status(http.StatusInternalServerError)
	} else if validResponse, ok := response.(GetSessionSnapshotsResponseObject); ok {
		if err := validResponse.VisitGetSessionSnapshotsResponse(ctx.Writer); err != nil {
			ctx.Error(err)
		}
	} else if response != nil {
		ctx.Error(fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
